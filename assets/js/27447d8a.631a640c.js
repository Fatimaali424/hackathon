"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3110],{1516(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1/ros2-integration","title":"ROS 2 Integration","description":"Overview","source":"@site/docs/module-1/ros2-integration.md","sourceDirName":"module-1","slug":"/module-1/ros2-integration","permalink":"/hackathon/docs/module-1/ros2-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/Fatimaali424/hackathon/edit/main/website/docs/module-1/ros2-integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Architecture","permalink":"/hackathon/docs/module-1/ros2-architecture"},"next":{"title":"Lab 1: Basic ROS 2 Publisher/Subscriber","permalink":"/hackathon/docs/module-1/lab-1-publisher-subscriber"}}');var i=r(4848),a=r(8453);const s={sidebar_position:4},o="ROS 2 Integration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Hardware Integration Overview",id:"hardware-integration-overview",level:2},{value:"ROS 2 Hardware Abstraction Layer",id:"ros-2-hardware-abstraction-layer",level:3},{value:"Sensor Integration",id:"sensor-integration",level:2},{value:"Camera Integration",id:"camera-integration",level:3},{value:"LIDAR Integration",id:"lidar-integration",level:3},{value:"Control System Integration",id:"control-system-integration",level:2},{value:"ROS 2 Control Framework",id:"ros-2-control-framework",level:3},{value:"Joint State Publisher",id:"joint-state-publisher",level:3},{value:"Communication with External Systems",id:"communication-with-external-systems",level:2},{value:"Serial Communication",id:"serial-communication",level:3},{value:"CAN Bus Integration",id:"can-bus-integration",level:3},{value:"Simulation Integration",id:"simulation-integration",level:2},{value:"Gazebo Integration",id:"gazebo-integration",level:3},{value:"Real-time Considerations",id:"real-time-considerations",level:2},{value:"Real-time Setup",id:"real-time-setup",level:3},{value:"Real-time Scheduling",id:"real-time-scheduling",level:3},{value:"Deployment on Embedded Systems",id:"deployment-on-embedded-systems",level:2},{value:"Resource Optimization",id:"resource-optimization",level:3},{value:"Docker for Deployment",id:"docker-for-deployment",level:3},{value:"Debugging and Monitoring",id:"debugging-and-monitoring",level:2},{value:"System Monitoring",id:"system-monitoring",level:3},{value:"Best Practices for Integration",id:"best-practices-for-integration",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-integration",children:"ROS 2 Integration"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This chapter focuses on integrating ROS 2 with real robotic systems, covering practical implementation techniques, hardware interfaces, and deployment strategies. We'll explore how to connect ROS 2 with various sensors, actuators, and control systems to create complete robotic applications."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Integrate ROS 2 with hardware sensors and actuators"}),"\n",(0,i.jsx)(n.li,{children:"Implement robot drivers and hardware interfaces"}),"\n",(0,i.jsx)(n.li,{children:"Configure and use ROS 2 control frameworks"}),"\n",(0,i.jsx)(n.li,{children:"Deploy ROS 2 applications on embedded systems"}),"\n",(0,i.jsx)(n.li,{children:"Integrate with simulation environments"}),"\n",(0,i.jsx)(n.li,{children:"Handle real-time constraints in robotic systems"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"hardware-integration-overview",children:"Hardware Integration Overview"}),"\n",(0,i.jsx)(n.h3,{id:"ros-2-hardware-abstraction-layer",children:"ROS 2 Hardware Abstraction Layer"}),"\n",(0,i.jsxs)(n.p,{children:["ROS 2 provides a standardized interface for hardware integration through the ",(0,i.jsx)(n.code,{children:"ros2_control"})," framework. This framework abstracts hardware-specific details and provides a consistent interface for controlling robots."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Example of a hardware interface\n#include "hardware_interface/handle.hpp"\n#include "hardware_interface/hardware_info.hpp"\n#include "hardware_interface/system_interface.hpp"\n#include "hardware_interface/types/hardware_interface_return_values.hpp"\n\nclass MyRobotHardware : public hardware_interface::SystemInterface\n{\npublic:\n    hardware_interface::CallbackReturn on_init(const hardware_interface::HardwareInfo & info) override\n    {\n        if (SystemInterface::on_init(info) != CallbackReturn::SUCCESS)\n        {\n            return CallbackReturn::ERROR;\n        }\n\n        // Initialize hardware components\n        // Parse configuration from URDF\n        return CallbackReturn::SUCCESS;\n    }\n\n    std::vector<hardware_interface::StateInterface> export_state_interfaces() override\n    {\n        std::vector<hardware_interface::StateInterface> state_interfaces;\n\n        // Export state interfaces for joints\n        for (auto i = 0u; i < info_.joints.size(); i++)\n        {\n            state_interfaces.emplace_back(\n                hardware_interface::StateInterface(\n                    info_.joints[i].name, hardware_interface::HW_IF_POSITION, &hw_positions_[i]));\n            state_interfaces.emplace_back(\n                hardware_interface::StateInterface(\n                    info_.joints[i].name, hardware_interface::HW_IF_VELOCITY, &hw_velocities_[i]));\n        }\n\n        return state_interfaces;\n    }\n\n    std::vector<hardware_interface::CommandInterface> export_command_interfaces() override\n    {\n        std::vector<hardware_interface::CommandInterface> command_interfaces;\n\n        // Export command interfaces for joints\n        for (auto i = 0u; i < info_.joints.size(); i++)\n        {\n            command_interfaces.emplace_back(\n                hardware_interface::CommandInterface(\n                    info_.joints[i].name, hardware_interface::HW_IF_POSITION, &hw_commands_[i]));\n        }\n\n        return command_interfaces;\n    }\n\n    hardware_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override\n    {\n        // Activate hardware\n        return SystemInterface::on_activate(previous_state);\n    }\n\n    hardware_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override\n    {\n        // Deactivate hardware\n        return SystemInterface::on_deactivate(previous_state);\n    }\n\n    hardware_interface::return_type read(const rclcpp::Time & time, const rclcpp::Duration & period) override\n    {\n        // Read data from hardware\n        return hardware_interface::return_type::OK;\n    }\n\n    hardware_interface::return_type write(const rclcpp::Time & time, const rclcpp::Duration & period) override\n    {\n        // Write commands to hardware\n        return hardware_interface::return_type::OK;\n    }\n\nprivate:\n    std::vector<double> hw_commands_;\n    std::vector<double> hw_positions_;\n    std::vector<double> hw_velocities_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,i.jsx)(n.h3,{id:"camera-integration",children:"Camera Integration"}),"\n",(0,i.jsxs)(n.p,{children:["Integrating cameras with ROS 2 requires using the ",(0,i.jsx)(n.code,{children:"image_transport"})," package and appropriate camera drivers:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example camera publisher node\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport cv2\n\nclass CameraPublisher(Node):\n    def __init__(self):\n        super().__init__('camera_publisher')\n        self.publisher_ = self.create_publisher(Image, 'camera/image_raw', 10)\n        self.bridge = CvBridge()\n        self.timer = self.create_timer(0.1, self.timer_callback)  # 10 Hz\n        self.cap = cv2.VideoCapture(0)\n\n    def timer_callback(self):\n        ret, frame = self.cap.read()\n        if ret:\n            msg = self.bridge.cv2_to_imgmsg(frame, encoding='bgr8')\n            self.publisher_.publish(msg)\n\n    def destroy_node(self):\n        self.cap.release()\n        super().destroy_node()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lidar-integration",children:"LIDAR Integration"}),"\n",(0,i.jsxs)(n.p,{children:["LIDAR sensors typically publish point cloud data in the ",(0,i.jsx)(n.code,{children:"sensor_msgs/PointCloud2"})," format:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Example LIDAR interface\n#include "sensor_msgs/msg/point_cloud2.hpp"\n#include "sensor_msgs/point_cloud2_iterator.hpp"\n\nclass LIDARInterface : public rclcpp::Node\n{\npublic:\n    LIDARInterface() : Node("lidar_interface")\n    {\n        publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>("lidar/points", 10);\n    }\n\nprivate:\n    void process_lidar_data(const std::vector<float>& ranges)\n    {\n        auto msg = sensor_msgs::msg::PointCloud2();\n        msg.header.stamp = this->get_clock()->now();\n        msg.header.frame_id = "lidar_link";\n\n        // Configure message structure\n        msg.height = 1;\n        msg.width = ranges.size();\n        msg.is_dense = false;\n        msg.is_bigendian = false;\n\n        // Define fields\n        sensor_msgs::PointCloud2Modifier modifier(msg);\n        modifier.setPointCloud2FieldsByString(2, "xyz", "rgb");\n\n        // Fill point cloud data\n        sensor_msgs::PointCloud2Iterator<float> iter_x(msg, "x");\n        sensor_msgs::PointCloud2Iterator<float> iter_y(msg, "y");\n        sensor_msgs::PointCloud2Iterator<float> iter_z(msg, "z");\n\n        for (size_t i = 0; i < ranges.size(); ++i)\n        {\n            *iter_x = ranges[i] * cos(angle_increment * i);\n            *iter_y = ranges[i] * sin(angle_increment * i);\n            *iter_z = 0.0;\n            ++iter_x;\n            ++iter_y;\n            ++iter_z;\n        }\n\n        publisher_->publish(msg);\n    }\n\n    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr publisher_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"control-system-integration",children:"Control System Integration"}),"\n",(0,i.jsx)(n.h3,{id:"ros-2-control-framework",children:"ROS 2 Control Framework"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ros2_control"})," framework provides standardized interfaces for robot control:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Example controller configuration (controllers.yaml)\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    forward_position_controller:\n      type: position_controllers/JointGroupPositionController\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\nforward_position_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n    command_interfaces:\n      - position\n    state_interfaces:\n      - position\n      - velocity\n"})}),"\n",(0,i.jsx)(n.h3,{id:"joint-state-publisher",children:"Joint State Publisher"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example joint state publisher\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)\n        self.timer = self.create_timer(0.05, self.publish_joint_states)  # 20 Hz\n\n        # Initialize joint names and positions\n        self.joint_names = ['joint1', 'joint2', 'joint3']\n        self.joint_positions = [0.0, 0.0, 0.0]\n        self.joint_velocities = [0.0, 0.0, 0.0]\n        self.joint_efforts = [0.0, 0.0, 0.0]\n\n    def publish_joint_states(self):\n        msg = JointState()\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        self.publisher_.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"communication-with-external-systems",children:"Communication with External Systems"}),"\n",(0,i.jsx)(n.h3,{id:"serial-communication",children:"Serial Communication"}),"\n",(0,i.jsx)(n.p,{children:"Many hardware devices communicate via serial protocols:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example serial communication node\nimport rclpy\nfrom rclpy.node import Node\nimport serial\nimport struct\n\nclass SerialInterface(Node):\n    def __init__(self):\n        super().__init__('serial_interface')\n        self.publisher_ = self.create_publisher(String, 'serial_data', 10)\n        self.subscription_ = self.create_subscription(\n            String, 'serial_command', self.command_callback, 10)\n\n        # Connect to hardware\n        self.serial_port = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)\n        self.timer = self.create_timer(0.01, self.read_serial)\n\n    def read_serial(self):\n        if self.serial_port.in_waiting > 0:\n            data = self.serial_port.readline().decode('utf-8').strip()\n            if data:\n                msg = String()\n                msg.data = data\n                self.publisher_.publish(msg)\n\n    def command_callback(self, msg):\n        command = msg.data + '\\n'\n        self.serial_port.write(command.encode())\n"})}),"\n",(0,i.jsx)(n.h3,{id:"can-bus-integration",children:"CAN Bus Integration"}),"\n",(0,i.jsx)(n.p,{children:"For automotive and industrial applications, CAN bus integration is essential:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Example CAN interface (using socketcan)\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <net/if.h>\n#include <unistd.h>\n\nclass CANInterface : public rclcpp::Node\n{\npublic:\n    CANInterface() : Node("can_interface")\n    {\n        publisher_ = this->create_publisher<can_msgs::msg::Frame>("can_rx", 10);\n        subscription_ = this->create_subscription<can_msgs::msg::Frame>(\n            "can_tx", 10, std::bind(&CANInterface::can_tx_callback, this, std::placeholders::_1));\n\n        // Initialize CAN socket\n        init_can_socket();\n    }\n\nprivate:\n    void init_can_socket()\n    {\n        socket_ = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n        if (socket_ < 0) {\n            RCLCPP_ERROR(this->get_logger(), "Failed to create CAN socket");\n            return;\n        }\n\n        struct ifreq ifr;\n        strcpy(ifr.ifr_name, "can0");\n        ioctl(socket_, SIOCGIFINDEX, &ifr);\n\n        struct sockaddr_can addr;\n        memset(&addr, 0, sizeof(addr));\n        addr.can_family = AF_CAN;\n        addr.can_ifindex = ifr.ifr_ifindex;\n\n        if (bind(socket_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n            RCLCPP_ERROR(this->get_logger(), "Failed to bind CAN socket");\n            return;\n        }\n    }\n\n    void can_tx_callback(const can_msgs::msg::Frame::SharedPtr msg)\n    {\n        struct can_frame frame;\n        frame.can_id = msg->id;\n        frame.can_dlc = msg->dlc;\n        memcpy(frame.data, msg->data.data(), frame.can_dlc);\n\n        write(socket_, &frame, sizeof(frame));\n    }\n\n    int socket_;\n    rclcpp::Publisher<can_msgs::msg::Frame>::SharedPtr publisher_;\n    rclcpp::Subscription<can_msgs::msg::Frame>::SharedPtr subscription_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-integration",children:"Simulation Integration"}),"\n",(0,i.jsx)(n.h3,{id:"gazebo-integration",children:"Gazebo Integration"}),"\n",(0,i.jsxs)(n.p,{children:["ROS 2 integrates with Gazebo through the ",(0,i.jsx)(n.code,{children:"ros_gz"})," bridge:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example URDF with Gazebo plugins --\x3e\n<?xml version="1.0"?>\n<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.5 0.2"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.5 0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n\n  <gazebo>\n    <plugin filename="libgazebo_ros_diff_drive.so" name="diff_drive">\n      <left_joint>left_wheel_joint</left_joint>\n      <right_joint>right_wheel_joint</right_joint>\n      <wheel_separation>0.3</wheel_separation>\n      <wheel_diameter>0.15</wheel_diameter>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-time-considerations",children:"Real-time Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"real-time-setup",children:"Real-time Setup"}),"\n",(0,i.jsx)(n.p,{children:"For time-critical applications, ROS 2 can be configured for real-time performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Configure kernel for real-time\necho 'kernel.sched_rt_runtime_us = -1' | sudo tee -a /etc/security/limits.conf\necho 'kernel.sched_rt_period_us = 1000000' | sudo tee -a /etc/security/limits.conf\n\n# Add user to real-time group\nsudo usermod -a -G realtime $USER\n"})}),"\n",(0,i.jsx)(n.h3,{id:"real-time-scheduling",children:"Real-time Scheduling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Example of setting real-time priority\n#include <sched.h>\n#include <sys/mman.h>\n\nclass RealTimeNode : public rclcpp::Node\n{\npublic:\n    RealTimeNode() : Node("realtime_node")\n    {\n        // Lock memory to prevent page faults\n        mlockall(MCL_CURRENT | MCL_FUTURE);\n\n        // Set real-time scheduling policy\n        struct sched_param param;\n        param.sched_priority = 80;  // High priority\n        if (sched_setscheduler(0, SCHED_FIFO, &param) == -1) {\n            RCLCPP_WARN(this->get_logger(), "Failed to set real-time priority");\n        }\n\n        // Create real-time timer\n        timer_ = this->create_wall_timer(\n            std::chrono::milliseconds(10),\n            std::bind(&RealTimeNode::realtime_callback, this));\n    }\n\nprivate:\n    void realtime_callback()\n    {\n        // Time-critical callback code\n        // This will run with real-time priority\n    }\n\n    rclcpp::TimerBase::SharedPtr timer_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"deployment-on-embedded-systems",children:"Deployment on Embedded Systems"}),"\n",(0,i.jsx)(n.h3,{id:"resource-optimization",children:"Resource Optimization"}),"\n",(0,i.jsx)(n.p,{children:"When deploying on embedded systems, consider resource constraints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Cross-compilation for embedded systems\ncolcon build --merge-install --packages-select my_robot_package \\\n  --cmake-args -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake\n"})}),"\n",(0,i.jsx)(n.h3,{id:"docker-for-deployment",children:"Docker for Deployment"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'# Example Dockerfile for ROS 2 application\nFROM ros:humble-ros-base-jammy\n\n# Install dependencies\nRUN apt-get update && apt-get install -y \\\n    ros-humble-ros2-control \\\n    ros-humble-ros2-controllers \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy application\nCOPY . /app\nWORKDIR /app\n\n# Build application\nRUN . /opt/ros/humble/setup.sh && \\\n    colcon build --packages-select my_robot_package\n\n# Source ROS and run application\nCMD ["/bin/bash", "-c", "source /opt/ros/humble/setup.sh && source install/setup.sh && ros2 run my_robot_package my_robot_node"]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-and-monitoring",children:"Debugging and Monitoring"}),"\n",(0,i.jsx)(n.h3,{id:"system-monitoring",children:"System Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example system monitoring node\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nimport psutil\nimport json\n\nclass SystemMonitor(Node):\n    def __init__(self):\n        super().__init__('system_monitor')\n        self.publisher_ = self.create_publisher(String, 'system_status', 10)\n        self.timer = self.create_timer(1.0, self.monitor_system)\n\n    def monitor_system(self):\n        status = {\n            'cpu_percent': psutil.cpu_percent(),\n            'memory_percent': psutil.virtual_memory().percent,\n            'disk_percent': psutil.disk_usage('/').percent,\n            'temperature': self.get_temperature(),\n            'timestamp': self.get_clock().now().to_msg()\n        }\n\n        msg = String()\n        msg.data = json.dumps(status)\n        self.publisher_.publish(msg)\n\n    def get_temperature(self):\n        # Implementation depends on hardware\n        # This is a placeholder\n        return 35.0  # degrees Celsius\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-integration",children:"Best Practices for Integration"}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Robust error handling for hardware interfaces\nclass RobustHardwareInterface : public rclcpp::Node\n{\npublic:\n    RobustHardwareInterface() : Node("robust_hardware_interface")\n    {\n        // Initialize with error handling\n        if (!initialize_hardware()) {\n            RCLCPP_ERROR(this->get_logger(), "Failed to initialize hardware, shutting down");\n            rclcpp::shutdown();\n            return;\n        }\n\n        // Setup error monitoring\n        error_timer_ = this->create_timer(\n            std::chrono::seconds(1),\n            std::bind(&RobustHardwareInterface::check_hardware_status, this));\n    }\n\nprivate:\n    bool initialize_hardware()\n    {\n        try {\n            // Hardware initialization code\n            return true;\n        } catch (const std::exception& e) {\n            RCLCPP_ERROR(this->get_logger(), "Hardware initialization failed: %s", e.what());\n            return false;\n        }\n    }\n\n    void check_hardware_status()\n    {\n        if (!is_hardware_connected()) {\n            RCLCPP_WARN(this->get_logger(), "Hardware connection lost");\n            // Implement recovery strategy\n        }\n    }\n\n    rclcpp::TimerBase::SharedPtr error_timer_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered the practical aspects of integrating ROS 2 with real robotic systems, including hardware interfaces, control systems, and deployment strategies. We explored various integration patterns, real-time considerations, and best practices for robust robotic applications."}),"\n",(0,i.jsx)(n.p,{children:"The next phase will involve implementing lab exercises that apply these concepts in practical scenarios, starting with basic publisher/subscriber patterns and progressing to more complex multi-node systems."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);