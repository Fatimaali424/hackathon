"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9622],{3884(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"capstone/planning","title":"Planning System Integration","description":"Overview","source":"@site/docs/capstone/planning.md","sourceDirName":"capstone","slug":"/capstone/planning","permalink":"/hackathon/docs/capstone/planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Fatimaali424/hackathon/edit/main/website/docs/capstone/planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Voice Command Processing","permalink":"/hackathon/docs/capstone/voice-command"},"next":{"title":"Navigation System Integration","permalink":"/hackathon/docs/capstone/navigation"}}');var a=t(4848),s=t(8453);const r={sidebar_position:3},o="Planning System Integration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Planning Architecture",id:"planning-architecture",level:2},{value:"Hierarchical Planning Structure",id:"hierarchical-planning-structure",level:3},{value:"High-Level Task Planning",id:"high-level-task-planning",level:2},{value:"Task Decomposition",id:"task-decomposition",level:3},{value:"Motion Planning Integration",id:"motion-planning-integration",level:2},{value:"Path Planning System",id:"path-planning-system",level:3},{value:"Task Execution Planning",id:"task-execution-planning",level:2},{value:"Execution Planner",id:"execution-planner",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"planning-system-integration",children:"Planning System Integration"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The planning system integration is a critical component of the autonomous humanoid robot, responsible for transforming high-level user commands into executable action sequences. This system bridges the gap between command interpretation and physical execution, handling complex multi-step tasks that require navigation, manipulation, and coordination of various subsystems."}),"\n",(0,a.jsx)(n.p,{children:"The planning system must handle both high-level task planning (what to do) and motion planning (how to do it), ensuring that the robot can execute complex commands while respecting environmental constraints, safety requirements, and resource limitations."}),"\n",(0,a.jsx)(n.h2,{id:"planning-architecture",children:"Planning Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"hierarchical-planning-structure",children:"Hierarchical Planning Structure"}),"\n",(0,a.jsx)(n.p,{children:"The planning system follows a hierarchical architecture with multiple levels of abstraction:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    HIGH-LEVEL TASK PLANNER                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Task Decomposer \u2502  \u2502 Constraint      \u2502  \u2502 Plan Validator  \u2502 \u2502\n\u2502  \u2502                 \u2502  \u2502 Manager         \u2502  \u2502                 \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    MOTION PLANNING                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Path Planner    \u2502  \u2502 Trajectory      \u2502  \u2502 Collision       \u2502 \u2502\n\u2502  \u2502                 \u2502  \u2502 Generator       \u2502  \u2502 Checker         \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    EXECUTION PLANNER                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Navigation      \u2502  \u2502 Manipulation    \u2502  \u2502 Control         \u2502 \u2502\n\u2502  \u2502 Planner         \u2502  \u2502 Planner         \u2502  \u2502 Sequencer       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     LOW-LEVEL CONTROL                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Motor Control   \u2502  \u2502 Sensor Fusion   \u2502  \u2502 Safety Monitor  \u2502 \u2502\n\u2502  \u2502                 \u2502  \u2502                 \u2502  \u2502                 \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h2,{id:"high-level-task-planning",children:"High-Level Task Planning"}),"\n",(0,a.jsx)(n.h3,{id:"task-decomposition",children:"Task Decomposition"}),"\n",(0,a.jsx)(n.p,{children:"The high-level task planner decomposes complex user commands into manageable subtasks:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typing import List, Dict, Any, Optional, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport networkx as nx\nimport heapq\n\nclass TaskType(Enum):\n    NAVIGATION = "navigation"\n    MANIPULATION = "manipulation"\n    PERCEPTION = "perception"\n    COMMUNICATION = "communication"\n    WAIT = "wait"\n    CONDITIONAL = "conditional"\n\n@dataclass\nclass Task:\n    """Represents a single task in the plan"""\n    id: str\n    task_type: TaskType\n    description: str\n    parameters: Dict[str, Any]\n    dependencies: List[str]  # IDs of tasks that must complete first\n    priority: int = 0\n    estimated_duration: float = 0.0  # seconds\n    resources_required: List[str] = None  # e.g., "arm", "navigation", "camera"\n\n    def __post_init__(self):\n        if self.resources_required is None:\n            self.resources_required = []\n\n@dataclass\nclass Plan:\n    """Represents a complete execution plan"""\n    tasks: List[Task]\n    constraints: Dict[str, Any]\n    plan_graph: nx.DiGraph = None\n\n    def __post_init__(self):\n        self._build_plan_graph()\n\n    def _build_plan_graph(self):\n        """Build dependency graph for task execution"""\n        self.plan_graph = nx.DiGraph()\n\n        for task in self.tasks:\n            self.plan_graph.add_node(task.id, task=task)\n\n        for task in self.tasks:\n            for dep_id in task.dependencies:\n                self.plan_graph.add_edge(dep_id, task.id)\n\nclass HighLevelTaskPlanner:\n    def __init__(self):\n        self.task_database = self._initialize_task_database()\n        self.constraint_checker = ConstraintChecker()\n\n    def decompose_command(self, command_interpretation: Dict) -> Plan:\n        """Decompose high-level command into executable tasks"""\n        intent = command_interpretation.get(\'intent\')\n        entities = command_interpretation.get(\'entities\', {})\n\n        # Map command to task decomposition strategy\n        if intent == \'navigation\':\n            return self._decompose_navigation(entities)\n        elif intent == \'object_interaction\':\n            return self._decompose_object_interaction(entities)\n        elif intent == \'manipulation\':\n            return self._decompose_manipulation(entities)\n        elif intent == \'action\':\n            return self._decompose_action(entities)\n        else:\n            # For unknown intents, try to decompose based on entities\n            return self._decompose_generic(entities)\n\n    def _decompose_navigation(self, entities: Dict) -> Plan:\n        """Decompose navigation commands into tasks"""\n        tasks = []\n\n        # 1. Perceive current location\n        tasks.append(Task(\n            id="perceive_current_location",\n            task_type=TaskType.PERCEPTION,\n            description="Perceive current location",\n            parameters={"sensor": "camera"},\n            dependencies=[],\n            estimated_duration=2.0,\n            resources_required=["camera"]\n        ))\n\n        # 2. Plan path to destination\n        destination = entities.get(\'location\', \'unknown\')\n        tasks.append(Task(\n            id=f"plan_path_to_{destination}",\n            task_type=TaskType.NAVIGATION,\n            description=f"Plan path to {destination}",\n            parameters={"destination": destination},\n            dependencies=["perceive_current_location"],\n            estimated_duration=5.0,\n            resources_required=["navigation"]\n        ))\n\n        # 3. Navigate to destination\n        tasks.append(Task(\n            id=f"navigate_to_{destination}",\n            task_type=TaskType.NAVIGATION,\n            description=f"Navigate to {destination}",\n            parameters={"destination": destination},\n            dependencies=[f"plan_path_to_{destination}"],\n            estimated_duration=30.0,  # Variable based on distance\n            resources_required=["navigation", "sensors"]\n        ))\n\n        return Plan(tasks=tasks, constraints={\n            "max_navigation_time": 120.0,\n            "safety_distance": 0.5\n        })\n\n    def _decompose_object_interaction(self, entities: Dict) -> Plan:\n        """Decompose object interaction commands into tasks"""\n        tasks = []\n\n        obj = entities.get(\'object\', \'unknown\')\n        location = entities.get(\'location\', \'current\')\n\n        # 1. Navigate to object location\n        if location != \'current\':\n            tasks.append(Task(\n                id=f"navigate_to_{location}",\n                task_type=TaskType.NAVIGATION,\n                description=f"Navigate to {location}",\n                parameters={"destination": location},\n                dependencies=[],\n                estimated_duration=20.0,\n                resources_required=["navigation", "sensors"]\n            ))\n\n        # 2. Perceive object\n        nav_dep = [f"navigate_to_{location}"] if location != \'current\' else []\n        tasks.append(Task(\n            id=f"perceive_{obj}",\n            task_type=TaskType.PERCEPTION,\n            description=f"Perceive {obj}",\n            parameters={"object": obj, "sensor": "camera"},\n            dependencies=nav_dep,\n            estimated_duration=3.0,\n            resources_required=["camera", "perception"]\n        ))\n\n        # 3. Plan manipulation\n        perceive_dep = [f"perceive_{obj}"] + nav_dep\n        tasks.append(Task(\n            id=f"plan_grasp_{obj}",\n            task_type=TaskType.MANIPULATION,\n            description=f"Plan grasp for {obj}",\n            parameters={"object": obj, "action": "grasp"},\n            dependencies=perceive_dep,\n            estimated_duration=5.0,\n            resources_required=["manipulation_planner"]\n        ))\n\n        # 4. Execute manipulation\n        plan_dep = [f"plan_grasp_{obj}"] + perceive_dep\n        tasks.append(Task(\n            id=f"grasp_{obj}",\n            task_type=TaskType.MANIPULATION,\n            description=f"Grasp {obj}",\n            parameters={"object": obj, "action": "grasp"},\n            dependencies=plan_dep,\n            estimated_duration=10.0,\n            resources_required=["manipulation", "arm"]\n        ))\n\n        return Plan(tasks=tasks, constraints={\n            "max_manipulation_time": 60.0,\n            "object_recognition_threshold": 0.8\n        })\n\n    def _decompose_manipulation(self, entities: Dict) -> Plan:\n        """Decompose manipulation commands into tasks"""\n        tasks = []\n\n        obj = entities.get(\'object\', \'unknown\')\n        manipulation_type = entities.get(\'manipulation_type\', \'manipulate\')\n\n        # 1. Perceive object\n        tasks.append(Task(\n            id=f"perceive_{obj}",\n            task_type=TaskType.PERCEPTION,\n            description=f"Perceive {obj}",\n            parameters={"object": obj, "sensor": "camera"},\n            dependencies=[],\n            estimated_duration=3.0,\n            resources_required=["camera", "perception"]\n        ))\n\n        # 2. Plan manipulation\n        tasks.append(Task(\n            id=f"plan_{manipulation_type}_{obj}",\n            task_type=TaskType.MANIPULATION,\n            description=f"Plan {manipulation_type} for {obj}",\n            parameters={"object": obj, "action": manipulation_type},\n            dependencies=[f"perceive_{obj}"],\n            estimated_duration=5.0,\n            resources_required=["manipulation_planner"]\n        ))\n\n        # 3. Execute manipulation\n        tasks.append(Task(\n            id=f"{manipulation_type}_{obj}",\n            task_type=TaskType.MANIPULATION,\n            description=f"{manipulation_type.title()} {obj}",\n            parameters={"object": obj, "action": manipulation_type},\n            dependencies=[f"plan_{manipulation_type}_{obj}"],\n            estimated_duration=10.0,\n            resources_required=["manipulation", "arm"]\n        ))\n\n        return Plan(tasks=tasks, constraints={\n            "max_manipulation_time": 60.0,\n            "safety_force_limit": 10.0\n        })\n\n    def _decompose_generic(self, entities: Dict) -> Plan:\n        """Generic task decomposition for unknown intents"""\n        tasks = []\n\n        # Default to basic perception and navigation\n        tasks.append(Task(\n            id="perceive_environment",\n            task_type=TaskType.PERCEPTION,\n            description="Perceive environment",\n            parameters={"sensor": "camera"},\n            dependencies=[],\n            estimated_duration=2.0,\n            resources_required=["camera"]\n        ))\n\n        return Plan(tasks=tasks, constraints={\n            "max_execution_time": 300.0\n        })\n\n    def validate_plan(self, plan: Plan) -> Tuple[bool, List[str]]:\n        """Validate plan against constraints"""\n        violations = []\n\n        # Check for cycles in dependency graph\n        if not nx.is_directed_acyclic_graph(plan.plan_graph):\n            violations.append("Plan contains cyclic dependencies")\n\n        # Check resource conflicts\n        resource_conflicts = self._check_resource_conflicts(plan)\n        violations.extend(resource_conflicts)\n\n        # Check temporal constraints\n        temporal_violations = self._check_temporal_constraints(plan)\n        violations.extend(temporal_violations)\n\n        return len(violations) == 0, violations\n\n    def _check_resource_conflicts(self, plan: Plan) -> List[str]:\n        """Check for resource conflicts in plan"""\n        violations = []\n\n        # Simple resource conflict checking\n        for task in plan.tasks:\n            for other_task in plan.tasks:\n                if task.id != other_task.id:\n                    # Check if tasks require same resource and could conflict\n                    common_resources = set(task.resources_required) & set(other_task.resources_required)\n                    if common_resources:\n                        # Check if they have overlapping execution windows\n                        # This is simplified - in practice would check actual timing\n                        violations.append(f"Potential resource conflict between {task.id} and {other_task.id} for resources {common_resources}")\n\n        return violations\n\n    def _check_temporal_constraints(self, plan: Plan) -> List[str]:\n        """Check temporal constraints"""\n        violations = []\n\n        # Check if plan duration exceeds limits\n        total_estimated_time = sum(task.estimated_duration for task in plan.tasks)\n        max_time = plan.constraints.get("max_execution_time", float(\'inf\'))\n\n        if total_estimated_time > max_time:\n            violations.append(f"Plan estimated duration ({total_estimated_time}s) exceeds maximum allowed time ({max_time}s)")\n\n        return violations\n\n    def optimize_plan(self, plan: Plan) -> Plan:\n        """Optimize plan for efficiency"""\n        # This would implement plan optimization algorithms\n        # For now, return the original plan\n        return plan\n'})}),"\n",(0,a.jsx)(n.h2,{id:"motion-planning-integration",children:"Motion Planning Integration"}),"\n",(0,a.jsx)(n.h3,{id:"path-planning-system",children:"Path Planning System"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial import KDTree\nimport heapq\nfrom typing import Tuple, List, Optional\nimport matplotlib.pyplot as plt\n\nclass MotionPlanner:\n    def __init__(self, resolution=0.1, inflation_radius=0.5):\n        self.resolution = resolution\n        self.inflation_radius = inflation_radius\n        self.grid_map = None\n        self.occupancy_grid = None\n\n    def set_map(self, occupancy_grid: np.ndarray, origin: Tuple[float, float]):\n        """Set the occupancy grid map for planning"""\n        self.occupancy_grid = occupancy_grid\n        self.origin = origin\n        self.grid_resolution = 1.0  # Grid cell size in meters\n\n    def plan_path(self, start: Tuple[float, float], goal: Tuple[float, float]) -> Optional[List[Tuple[float, float]]]:\n        """Plan path using A* algorithm"""\n        if self.occupancy_grid is None:\n            raise ValueError("Map not set. Call set_map() first.")\n\n        # Convert world coordinates to grid coordinates\n        start_grid = self._world_to_grid(start)\n        goal_grid = self._world_to_grid(goal)\n\n        # Check if start and goal are valid\n        if not self._is_valid_cell(start_grid) or not self._is_valid_cell(goal_grid):\n            return None\n\n        # Run A* path planning\n        path_grid = self._a_star(start_grid, goal_grid)\n\n        if path_grid is None:\n            return None\n\n        # Convert grid path back to world coordinates\n        path_world = [self._grid_to_world(cell) for cell in path_grid]\n\n        return path_world\n\n    def _world_to_grid(self, world_coord: Tuple[float, float]) -> Tuple[int, int]:\n        """Convert world coordinates to grid coordinates"""\n        x, y = world_coord\n        grid_x = int((x - self.origin[0]) / self.grid_resolution)\n        grid_y = int((y - self.origin[1]) / self.grid_resolution)\n        return (grid_x, grid_y)\n\n    def _grid_to_world(self, grid_coord: Tuple[int, int]) -> Tuple[float, float]:\n        """Convert grid coordinates to world coordinates"""\n        grid_x, grid_y = grid_coord\n        world_x = self.origin[0] + grid_x * self.grid_resolution\n        world_y = self.origin[1] + grid_y * self.grid_resolution\n        return (world_x, world_y)\n\n    def _is_valid_cell(self, cell: Tuple[int, int]) -> bool:\n        """Check if grid cell is valid (within bounds and not occupied)"""\n        x, y = cell\n\n        # Check bounds\n        if x < 0 or x >= self.occupancy_grid.shape[1] or y < 0 or y >= self.occupancy_grid.shape[0]:\n            return False\n\n        # Check occupancy (assuming 100 = occupied, 0 = free)\n        return self.occupancy_grid[y, x] < 50  # Threshold for "free"\n\n    def _a_star(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:\n        """A* path planning algorithm"""\n        # Heuristic function (Euclidean distance)\n        def heuristic(a, b):\n            return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n\n        # Priority queue: (cost, position)\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: heuristic(start, goal)}\n\n        # Visited set\n        closed_set = set()\n\n        # 8-connected neighborhood\n        neighbors = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (0, -1),           (0, 1),\n            (1, -1),  (1, 0),  (1, 1)\n        ]\n\n        while open_set:\n            current_cost, current = heapq.heappop(open_set)\n\n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]  # Reverse to get start-to-goal\n\n            closed_set.add(current)\n\n            for dx, dy in neighbors:\n                neighbor = (current[0] + dx, current[1] + dy)\n\n                if neighbor in closed_set:\n                    continue\n\n                if not self._is_valid_cell(neighbor):\n                    continue\n\n                # Calculate tentative g_score\n                movement_cost = np.sqrt(dx**2 + dy**2)  # Diagonal movement cost\n                tentative_g = g_score[current] + movement_cost\n\n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                    # This path to neighbor is better\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g\n                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)\n\n                    if neighbor not in [item[1] for item in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        # No path found\n        return None\n\nclass TrajectoryGenerator:\n    """Generate smooth trajectories from path points"""\n\n    def __init__(self, max_velocity=1.0, max_acceleration=0.5):\n        self.max_velocity = max_velocity\n        self.max_acceleration = max_acceleration\n\n    def generate_trajectory(self, path: List[Tuple[float, float]],\n                           start_velocity: float = 0.0,\n                           end_velocity: float = 0.0) -> List[Dict[str, float]]:\n        """Generate trajectory with velocity profiles"""\n        if len(path) < 2:\n            return []\n\n        trajectory = []\n\n        # Calculate path length and segment lengths\n        total_length = 0.0\n        segment_lengths = []\n\n        for i in range(1, len(path)):\n            dx = path[i][0] - path[i-1][0]\n            dy = path[i][1] - path[i-1][1]\n            segment_length = np.sqrt(dx*dx + dy*dy)\n            segment_lengths.append(segment_length)\n            total_length += segment_length\n\n        # Generate trajectory points\n        cumulative_distance = 0.0\n        current_velocity = start_velocity\n\n        for i, (segment_length) in enumerate(segment_lengths):\n            # Calculate time for this segment (simplified)\n            # In practice, would use more sophisticated velocity profiling\n            avg_velocity = (self.max_velocity + current_velocity) / 2.0\n            segment_time = segment_length / avg_velocity if avg_velocity > 0 else 0.1\n\n            # Add point to trajectory\n            trajectory.append({\n                \'position\': path[i+1],\n                \'velocity\': current_velocity,\n                \'acceleration\': 0.0,  # Simplified\n                \'time\': cumulative_distance / self.max_velocity if self.max_velocity > 0 else 0,\n                \'segment_length\': segment_length\n            })\n\n            cumulative_distance += segment_length\n\n            # Update velocity for next segment (simplified)\n            current_velocity = min(self.max_velocity, current_velocity + self.max_acceleration * segment_time)\n\n        return trajectory\n'})}),"\n",(0,a.jsx)(n.h2,{id:"task-execution-planning",children:"Task Execution Planning"}),"\n",(0,a.jsx)(n.h3,{id:"execution-planner",children:"Execution Planner"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from datetime import datetime, timedelta\nimport threading\nimport time\n\nclass ExecutionPlanner:\n    \"\"\"Plans and manages execution of tasks\"\"\"\n\n    def __init__(self):\n        self.active_tasks = {}\n        self.completed_tasks = []\n        self.failed_tasks = []\n        self.resource_manager = ResourceManager()\n        self.execution_lock = threading.Lock()\n\n    def execute_plan(self, plan: Plan) -> Dict[str, Any]:\n        \"\"\"Execute a complete plan\"\"\"\n        start_time = time.time()\n\n        # Validate plan before execution\n        is_valid, violations = HighLevelTaskPlanner().validate_plan(plan)\n        if not is_valid:\n            return {\n                'success': False,\n                'error': f'Plan validation failed: {violations}',\n                'execution_time': 0.0,\n                'completed_tasks': [],\n                'failed_tasks': []\n            }\n\n        # Sort tasks by dependencies and priority\n        execution_order = self._determine_execution_order(plan)\n\n        # Execute tasks in order\n        for task_id in execution_order:\n            task = self._get_task_by_id(plan, task_id)\n\n            # Acquire required resources\n            resources_acquired = self.resource_manager.acquire_resources(task.resources_required)\n            if not resources_acquired:\n                self.failed_tasks.append(task_id)\n                continue\n\n            try:\n                # Execute task\n                task_result = self._execute_single_task(task)\n\n                if task_result['success']:\n                    self.completed_tasks.append(task_id)\n                else:\n                    self.failed_tasks.append(task_id)\n\n            except Exception as e:\n                self.failed_tasks.append(task_id)\n                print(f\"Task {task_id} failed with error: {e}\")\n            finally:\n                # Release resources\n                self.resource_manager.release_resources(task.resources_required)\n\n        total_time = time.time() - start_time\n\n        return {\n            'success': len(self.failed_tasks) == 0,\n            'execution_time': total_time,\n            'completed_tasks': self.completed_tasks.copy(),\n            'failed_tasks': self.failed_tasks.copy(),\n            'total_tasks': len(plan.tasks)\n        }\n\n    def _determine_execution_order(self, plan: Plan) -> List[str]:\n        \"\"\"Determine execution order based on dependencies and priorities\"\"\"\n        # Use topological sort for dependency ordering\n        topo_order = list(nx.topological_sort(plan.plan_graph))\n\n        # Group tasks by priority\n        priority_groups = {}\n        for task_id in topo_order:\n            task = plan.plan_graph.nodes[task_id]['task']\n            priority = task.priority\n            if priority not in priority_groups:\n                priority_groups[priority] = []\n            priority_groups[priority].append(task_id)\n\n        # Sort priorities (higher numbers = higher priority)\n        sorted_priorities = sorted(priority_groups.keys(), reverse=True)\n\n        # Build final order\n        execution_order = []\n        for priority in sorted_priorities:\n            execution_order.extend(priority_groups[priority])\n\n        return execution_order\n\n    def _get_task_by_id(self, plan: Plan, task_id: str):\n        \"\"\"Get task by ID from plan\"\"\"\n        for task in plan.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def _execute_single_task(self, task: Task) -> Dict[str, Any]:\n        \"\"\"Execute a single task\"\"\"\n        try:\n            # Simulate task execution\n            execution_time = task.estimated_duration\n            time.sleep(min(0.1, execution_time))  # Simulate execution time\n\n            # Simulate success/failure based on task type\n            success_probability = 0.9  # 90% success rate\n            success = np.random.random() < success_probability\n\n            return {\n                'success': success,\n                'task_id': task.id,\n                'execution_time': execution_time,\n                'result': 'Task completed successfully' if success else 'Task failed'\n            }\n        except Exception as e:\n            return {\n                'success': False,\n                'task_id': task.id,\n                'execution_time': 0.0,\n                'result': f'Task failed with error: {str(e)}'\n            }\n\nclass ResourceManager:\n    \"\"\"Manage shared resources for task execution\"\"\"\n\n    def __init__(self):\n        self.available_resources = {\n            'navigation': True,\n            'manipulation': True,\n            'camera': True,\n            'arm': True,\n            'sensors': True,\n            'perception': True,\n            'manipulation_planner': True\n        }\n        self.resource_locks = {resource: threading.Lock() for resource in self.available_resources}\n        self.resource_usage = {resource: None for resource in self.available_resources}  # Task ID using resource\n\n    def acquire_resources(self, resource_list: List[str]) -> bool:\n        \"\"\"Acquire required resources\"\"\"\n        acquired_resources = []\n\n        try:\n            for resource in resource_list:\n                if resource in self.resource_locks:\n                    if self.resource_locks[resource].acquire(blocking=False):\n                        if self.available_resources[resource]:\n                            self.available_resources[resource] = False\n                            acquired_resources.append(resource)\n                        else:\n                            # Resource not available, release previously acquired resources\n                            for acquired in acquired_resources:\n                                self.available_resources[acquired] = True\n                                self.resource_locks[acquired].release()\n                            return False\n                    else:\n                        # Could not acquire lock, release previously acquired resources\n                        for acquired in acquired_resources:\n                            self.available_resources[acquired] = True\n                            self.resource_locks[acquired].release()\n                        return False\n            return True\n        except Exception:\n            # On error, release all acquired resources\n            for acquired in acquired_resources:\n                self.available_resources[acquired] = True\n                self.resource_locks[acquired].release()\n            return False\n\n    def release_resources(self, resource_list: List[str]):\n        \"\"\"Release resources\"\"\"\n        for resource in resource_list:\n            if resource in self.resource_locks:\n                with self.resource_locks[resource]:\n                    self.available_resources[resource] = True\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);