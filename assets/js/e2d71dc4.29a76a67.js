"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7075],{6315(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-3/motion-planning","title":"Motion Planning & Trajectory Generation","description":"Overview","source":"@site/docs/module-3/motion-planning.md","sourceDirName":"module-3","slug":"/module-3/motion-planning","permalink":"/hackathon/docs/module-3/motion-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Fatimaali424/hackathon/edit/main/website/docs/module-3/motion-planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"NVIDIA Isaac Platform & Perception","permalink":"/hackathon/docs/module-3/isaac-platform"},"next":{"title":"Edge Deployment & Optimization","permalink":"/hackathon/docs/module-3/edge-deployment"}}');var a=t(4848),o=t(8453);const r={sidebar_position:3},s="Motion Planning & Trajectory Generation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Motion Planning Fundamentals",id:"motion-planning-fundamentals",level:2},{value:"Configuration Space (C-Space)",id:"configuration-space-c-space",level:3},{value:"Planning Problem Definition",id:"planning-problem-definition",level:3},{value:"Sampling-Based Motion Planning",id:"sampling-based-motion-planning",level:2},{value:"Probabilistic Roadmap (PRM)",id:"probabilistic-roadmap-prm",level:3},{value:"Rapidly-exploring Random Trees (RRT)",id:"rapidly-exploring-random-trees-rrt",level:3},{value:"GPU-Accelerated Sampling",id:"gpu-accelerated-sampling",level:3},{value:"Trajectory Generation",id:"trajectory-generation",level:2},{value:"Polynomial Trajectories",id:"polynomial-trajectories",level:3},{value:"Optimization-Based Trajectory Generation",id:"optimization-based-trajectory-generation",level:3},{value:"Isaac Motion Planning Components",id:"isaac-motion-planning-components",level:2},{value:"Isaac ROS Navigation",id:"isaac-ros-navigation",level:3},{value:"GPU-Accelerated Path Planning",id:"gpu-accelerated-path-planning",level:4},{value:"Trajectory Optimization",id:"trajectory-optimization",level:4},{value:"Isaac Navigation 2 (Nav2) Integration",id:"isaac-navigation-2-nav2-integration",level:3},{value:"Dynamic Motion Planning",id:"dynamic-motion-planning",level:2},{value:"Time-Varying Environments",id:"time-varying-environments",level:3},{value:"Reactive Planning",id:"reactive-planning",level:3},{value:"Trajectory Execution and Control",id:"trajectory-execution-and-control",level:2},{value:"Feedback Control for Trajectory Following",id:"feedback-control-for-trajectory-following",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"GPU-Accelerated Planning",id:"gpu-accelerated-planning",level:3},{value:"Parallel Collision Detection",id:"parallel-collision-detection",level:4},{value:"Batch Processing",id:"batch-processing",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Integration with Perception Systems",id:"integration-with-perception-systems",level:2},{value:"Perception-Planning Coupling",id:"perception-planning-coupling",level:3},{value:"Quality Assurance and Validation",id:"quality-assurance-and-validation",level:2},{value:"Planning Quality Metrics",id:"planning-quality-metrics",level:3},{value:"Simulation-Based Validation",id:"simulation-based-validation",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"motion-planning--trajectory-generation",children:"Motion Planning & Trajectory Generation"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Motion planning is the computational process of determining a sequence of valid configurations that move a robot from an initial state to a goal state while avoiding obstacles and satisfying various constraints. This chapter explores motion planning algorithms and trajectory generation techniques within the NVIDIA Isaac framework, emphasizing GPU-accelerated computation for real-time applications."}),"\n",(0,a.jsx)(e.p,{children:"Motion planning bridges the gap between perception and action, taking environmental understanding and generating executable motion commands for robotic systems."}),"\n",(0,a.jsx)(e.h2,{id:"motion-planning-fundamentals",children:"Motion Planning Fundamentals"}),"\n",(0,a.jsx)(e.h3,{id:"configuration-space-c-space",children:"Configuration Space (C-Space)"}),"\n",(0,a.jsx)(e.p,{children:"Motion planning operates in configuration space, where each point represents a complete robot configuration:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Free space (C_free)"}),": Configurations where the robot doesn't collide with obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Obstacle space (C_obs)"}),": Configurations where the robot collides with obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path planning"}),": Finding a continuous path in C_free from start to goal"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"For a robot with n degrees of freedom, the configuration space has n dimensions, making planning computationally challenging."}),"\n",(0,a.jsx)(e.h3,{id:"planning-problem-definition",children:"Planning Problem Definition"}),"\n",(0,a.jsx)(e.p,{children:"A motion planning problem consists of:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robot model"}),": Kinematic and dynamic properties"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environment"}),": Static and dynamic obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Start state"}),": Initial configuration and velocity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Goal state"}),": Desired configuration and velocity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Constraints"}),": Kinematic, dynamic, and environmental constraints"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimization criteria"}),": Path length, time, energy, safety"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"sampling-based-motion-planning",children:"Sampling-Based Motion Planning"}),"\n",(0,a.jsx)(e.h3,{id:"probabilistic-roadmap-prm",children:"Probabilistic Roadmap (PRM)"}),"\n",(0,a.jsx)(e.p,{children:"PRM pre-computes a roadmap of possible paths:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial import KDTree\nimport random\n\nclass ProbabilisticRoadmap:\n    def __init__(self, robot, environment, num_samples=1000):\n        self.robot = robot\n        self.environment = environment\n        self.samples = []\n        self.graph = {}\n        self.kdtree = None\n        self.num_samples = num_samples\n\n    def build_roadmap(self):\n        # Sample free configurations\n        for _ in range(self.num_samples):\n            q = self.sample_free_configuration()\n            if q is not None:\n                self.samples.append(q)\n\n        # Build k-d tree for nearest neighbor queries\n        self.kdtree = KDTree(self.samples)\n\n        # Connect nearby configurations\n        for i, q in enumerate(self.samples):\n            neighbors = self.get_neighbors(q, max_dist=1.0)\n            for j in neighbors:\n                if self.is_collision_free(q, self.samples[j]):\n                    if i not in self.graph:\n                        self.graph[i] = []\n                    if j not in self.graph:\n                        self.graph[j] = []\n                    self.graph[i].append(j)\n                    self.graph[j].append(i)\n\n    def sample_free_configuration(self):\n        # Sample configuration and check for collision\n        for _ in range(100):  # Max attempts\n            q = self.robot.sample_configuration()\n            if not self.environment.in_collision(self.robot, q):\n                return q\n        return None\n\n    def get_neighbors(self, q, max_dist):\n        # Find nearby configurations\n        indices = self.kdtree.query_ball_point(q, max_dist)\n        return [i for i in indices if i != self.kdtree.query(q)[1]]\n"})}),"\n",(0,a.jsx)(e.h3,{id:"rapidly-exploring-random-trees-rrt",children:"Rapidly-exploring Random Trees (RRT)"}),"\n",(0,a.jsx)(e.p,{children:"RRT incrementally builds a tree of possible paths:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class RRT:\n    def __init__(self, start, goal, environment, robot):\n        self.start = start\n        self.goal = goal\n        self.environment = environment\n        self.robot = robot\n        self.vertices = [start]\n        self.edges = {}\n        self.goal_bias = 0.1\n\n    def plan(self, max_iterations=10000):\n        for i in range(max_iterations):\n            # Sample random configuration\n            if random.random() < self.goal_bias:\n                q_rand = self.goal\n            else:\n                q_rand = self.sample_configuration()\n\n            # Find nearest vertex in tree\n            q_near = self.nearest_vertex(q_rand)\n\n            # Extend tree toward random configuration\n            q_new = self.extend(q_near, q_rand)\n\n            if q_new is not None:\n                self.add_vertex(q_new, q_near)\n\n                # Check if goal is reached\n                if self.is_goal_reached(q_new):\n                    return self.reconstruct_path(q_new)\n\n        return None  # No path found\n\n    def extend(self, q_from, q_to):\n        # Extend tree from q_from toward q_to\n        direction = np.array(q_to) - np.array(q_from)\n        distance = np.linalg.norm(direction)\n\n        if distance > self.max_step_size:\n            direction = direction / distance * self.max_step_size\n            q_new = tuple(np.array(q_from) + direction)\n        else:\n            q_new = q_to\n\n        # Check for collision along path\n        if self.is_collision_free(q_from, q_new):\n            return q_new\n        return None\n"})}),"\n",(0,a.jsx)(e.h3,{id:"gpu-accelerated-sampling",children:"GPU-Accelerated Sampling"}),"\n",(0,a.jsx)(e.p,{children:"Isaac leverages GPU acceleration for motion planning:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parallel collision checking"}),": Check multiple configurations simultaneously"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Batch nearest neighbor queries"}),": Process multiple queries in parallel"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parallel path validation"}),": Validate multiple potential paths concurrently"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,a.jsx)(e.h3,{id:"polynomial-trajectories",children:"Polynomial Trajectories"}),"\n",(0,a.jsx)(e.p,{children:"Generate smooth trajectories using polynomial interpolation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.optimize import minimize\n\nclass PolynomialTrajectory:\n    def __init__(self, degree=5):\n        self.degree = degree\n        self.coefficients = None\n\n    def generate_trajectory(self, start_state, end_state, duration):\n        # Define boundary conditions\n        # Position: q(0) = q_start, q(T) = q_end\n        # Velocity: q_dot(0) = v_start, q_dot(T) = v_end\n        # Acceleration: q_ddot(0) = a_start, q_ddot(T) = a_end\n\n        # Set up system of equations\n        t0, t1 = 0, duration\n        q0, q1 = start_state[0], end_state[0]\n        v0, v1 = start_state[1], end_state[1]\n        a0, a1 = start_state[2], end_state[2]\n\n        # Build constraint matrix\n        A = np.array([\n            [1, t0, t0**2, t0**3, t0**4, t0**5],      # q(0) = q0\n            [0, 1, 2*t0, 3*t0**2, 4*t0**3, 5*t0**4], # q_dot(0) = v0\n            [0, 0, 2, 6*t0, 12*t0**2, 20*t0**3],     # q_ddot(0) = a0\n            [1, t1, t1**2, t1**3, t1**4, t1**5],      # q(T) = q1\n            [0, 1, 2*t1, 3*t1**2, 4*t1**3, 5*t1**4], # q_dot(T) = v1\n            [0, 0, 2, 6*t1, 12*t1**2, 20*t1**3]      # q_ddot(T) = a1\n        ])\n\n        b = np.array([q0, v0, a0, q1, v1, a1])\n\n        # Solve for coefficients\n        self.coefficients = np.linalg.solve(A, b)\n        return self.coefficients\n\n    def evaluate(self, t):\n        # Evaluate trajectory at time t\n        if self.coefficients is None:\n            raise ValueError("Trajectory not generated")\n\n        result = 0\n        for i, coeff in enumerate(self.coefficients):\n            result += coeff * (t ** i)\n        return result\n\n    def evaluate_derivative(self, t, order=1):\n        # Evaluate derivative of trajectory at time t\n        if self.coefficients is None:\n            raise ValueError("Trajectory not generated")\n\n        result = 0\n        for i in range(order, len(self.coefficients)):\n            coeff = self.coefficients[i]\n            # Calculate derivative coefficient\n            for j in range(order):\n                coeff *= (i - j)\n            result += coeff * (t ** (i - order))\n        return result\n'})}),"\n",(0,a.jsx)(e.h3,{id:"optimization-based-trajectory-generation",children:"Optimization-Based Trajectory Generation"}),"\n",(0,a.jsx)(e.p,{children:"Use optimization to generate trajectories that minimize cost functions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from scipy.optimize import minimize\nimport numpy as np\n\nclass OptimizedTrajectory:\n    def __init__(self, environment, robot):\n        self.environment = environment\n        self.robot = robot\n        self.waypoints = None\n\n    def generate_trajectory(self, start, goal, num_waypoints=10):\n        # Optimize trajectory to minimize cost function\n        # Cost function includes: path length, obstacle clearance, smoothness\n\n        def cost_function(waypoints_flat):\n            # Reshape flat array to waypoints\n            waypoints = waypoints_flat.reshape(-1, len(start))\n\n            # Calculate path length\n            path_length = 0\n            for i in range(1, len(waypoints)):\n                path_length += np.linalg.norm(waypoints[i] - waypoints[i-1])\n\n            # Calculate obstacle clearance penalty\n            clearance_penalty = 0\n            for waypoint in waypoints:\n                dist_to_obstacle = self.environment.distance_to_obstacle(waypoint)\n                if dist_to_obstacle < 0.5:  # Within 0.5m of obstacle\n                    clearance_penalty += (0.5 - dist_to_obstacle) ** 2\n\n            # Calculate smoothness penalty\n            smoothness_penalty = 0\n            for i in range(1, len(waypoints) - 1):\n                prev_to_curr = waypoints[i] - waypoints[i-1]\n                curr_to_next = waypoints[i+1] - waypoints[i]\n                angle_deviation = np.arccos(\n                    np.clip(np.dot(prev_to_curr, curr_to_next) /\n                           (np.linalg.norm(prev_to_curr) * np.linalg.norm(curr_to_next)), -1, 1)\n                )\n                smoothness_penalty += angle_deviation ** 2\n\n            return path_length + 10 * clearance_penalty + 5 * smoothness_penalty\n\n        # Initial guess: straight line from start to goal\n        initial_waypoints = np.linspace(start, goal, num_waypoints)\n        initial_flat = initial_waypoints.flatten()\n\n        # Optimize\n        result = minimize(\n            cost_function,\n            initial_flat,\n            method='L-BFGS-B',\n            options={'maxiter': 1000}\n        )\n\n        self.waypoints = result.x.reshape(-1, len(start))\n        return self.waypoints\n"})}),"\n",(0,a.jsx)(e.h2,{id:"isaac-motion-planning-components",children:"Isaac Motion Planning Components"}),"\n",(0,a.jsx)(e.h3,{id:"isaac-ros-navigation",children:"Isaac ROS Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Isaac ROS provides GPU-accelerated navigation components:"}),"\n",(0,a.jsx)(e.h4,{id:"gpu-accelerated-path-planning",children:"GPU-Accelerated Path Planning"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"CUDA-based A"}),"*: Parallel A* implementation for grid-based planning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"GPU Dijkstra"}),": Accelerated Dijkstra algorithm for weighted graphs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Voronoi-based planning"}),": GPU-accelerated Voronoi diagram computation"]}),"\n"]}),"\n",(0,a.jsx)(e.h4,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"MPC (Model Predictive Control)"}),": GPU-accelerated receding horizon control"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Nonlinear optimization"}),": Real-time trajectory optimization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Reactive planning for moving obstacles"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"isaac-navigation-2-nav2-integration",children:"Isaac Navigation 2 (Nav2) Integration"}),"\n",(0,a.jsx)(e.p,{children:"Isaac extends ROS 2 Navigation with GPU acceleration:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Isaac-accelerated navigation example\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import LaserScan\nfrom isaac_ros_nav_interfaces.srv import ComputePathToPose\n\nclass IsaacPathPlanner(Node):\n    def __init__(self):\n        super().__init__('isaac_path_planner')\n\n        # Publishers and subscribers\n        self.path_pub = self.create_publisher(Path, '/plan', 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10\n        )\n\n        # Service server for path computation\n        self.compute_path_srv = self.create_service(\n            ComputePathToPose,\n            '/compute_path_to_pose',\n            self.compute_path_callback\n        )\n\n        # Isaac-accelerated planner\n        self.planner = self.initialize_isaac_planner()\n\n    def initialize_isaac_planner(self):\n        # Initialize GPU-accelerated planner\n        # This would use Isaac's CUDA-based planning algorithms\n        pass\n\n    def compute_path_callback(self, request, response):\n        try:\n            # Use Isaac GPU-accelerated planning\n            path = self.planner.plan(\n                start=request.start,\n                goal=request.goal,\n                map_resolution=0.05  # 5cm resolution\n            )\n\n            response.path = path\n            response.error_code = 0\n            response.error_message = \"Success\"\n\n            # Publish path for visualization\n            self.path_pub.publish(path)\n\n        except Exception as e:\n            response.error_code = -1\n            response.error_message = f\"Planning failed: {str(e)}\"\n\n        return response\n\n    def scan_callback(self, msg):\n        # Update local costmap with laser scan data\n        # This would use Isaac's GPU-accelerated costmap updates\n        pass\n"})}),"\n",(0,a.jsx)(e.h2,{id:"dynamic-motion-planning",children:"Dynamic Motion Planning"}),"\n",(0,a.jsx)(e.h3,{id:"time-varying-environments",children:"Time-Varying Environments"}),"\n",(0,a.jsx)(e.p,{children:"Handle environments with moving obstacles:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class DynamicMotionPlanner:\n    def __init__(self, environment):\n        self.environment = environment\n        self.predicted_obstacles = {}  # Obstacle trajectories\n        self.replanning_threshold = 0.5  # Replan if obstacle within 0.5m\n\n    def plan_with_prediction(self, start, goal, current_time):\n        # Predict obstacle positions at future times\n        predicted_environment = self.predict_environment(current_time)\n\n        # Plan in predicted environment\n        path = self.plan_static(predicted_environment, start, goal)\n\n        # Monitor for replanning opportunities\n        self.schedule_replanning(path, current_time)\n\n        return path\n\n    def predict_environment(self, current_time):\n        # Predict obstacle positions using motion models\n        future_environment = self.environment.copy()\n\n        for obstacle_id, trajectory in self.predicted_obstacles.items():\n            predicted_pos = trajectory.predict(current_time)\n            future_environment.update_obstacle_position(obstacle_id, predicted_pos)\n\n        return future_environment\n\n    def schedule_replanning(self, path, current_time):\n        # Check if replanning is needed based on new sensor data\n        def replan_if_needed():\n            current_obstacles = self.get_current_obstacles()\n            if self.path_is_invalid(path, current_obstacles):\n                new_path = self.plan_with_prediction(\n                    path.poses[0].pose,  # Current position\n                    path.poses[-1].pose,  # Goal position\n                    current_time\n                )\n                return new_path\n        return replan_if_needed\n"})}),"\n",(0,a.jsx)(e.h3,{id:"reactive-planning",children:"Reactive Planning"}),"\n",(0,a.jsx)(e.p,{children:"Combine global planning with local reactive behaviors:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ReactivePlanner:\n    def __init__(self, global_planner, local_planner):\n        self.global_planner = global_planner\n        self.local_planner = local_planner\n        self.current_path = None\n        self.lookahead_distance = 1.0\n\n    def plan(self, robot_state, goal, sensor_data):\n        # Check if global replanning is needed\n        if self.should_replan(robot_state, goal):\n            self.current_path = self.global_planner.plan(\n                robot_state.pose, goal\n            )\n\n        # Generate local trajectory using local planner\n        local_goal = self.get_local_goal(robot_state)\n        local_trajectory = self.local_planner.plan(\n            robot_state, local_goal, sensor_data\n        )\n\n        return local_trajectory\n\n    def should_replan(self, robot_state, goal):\n        # Replan if too far from global path or goal changed significantly\n        if self.current_path is None:\n            return True\n\n        distance_to_path = self.compute_distance_to_path(\n            robot_state.pose, self.current_path\n        )\n\n        return distance_to_path > self.replanning_threshold\n"})}),"\n",(0,a.jsx)(e.h2,{id:"trajectory-execution-and-control",children:"Trajectory Execution and Control"}),"\n",(0,a.jsx)(e.h3,{id:"feedback-control-for-trajectory-following",children:"Feedback Control for Trajectory Following"}),"\n",(0,a.jsx)(e.p,{children:"Implement control systems to follow planned trajectories:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class TrajectoryFollower:\n    def __init__(self, robot_model):\n        self.robot_model = robot_model\n        self.current_trajectory = None\n        self.current_index = 0\n        self.lookahead_distance = 0.5\n        self.kp = 2.0  # Proportional gain\n        self.ki = 0.1  # Integral gain\n        self.kd = 0.05 # Derivative gain\n\n    def follow_trajectory(self, current_state, trajectory):\n        # Find closest point on trajectory\n        closest_idx = self.find_closest_point(current_state, trajectory)\n\n        # Determine lookahead point\n        lookahead_idx = self.find_lookahead_point(\n            current_state, trajectory, closest_idx\n        )\n\n        # Calculate control command\n        control_cmd = self.compute_control(\n            current_state, trajectory, lookahead_idx\n        )\n\n        return control_cmd\n\n    def find_lookahead_point(self, current_state, trajectory, start_idx):\n        # Find point on trajectory at lookahead distance\n        current_pos = np.array([current_state.pose.position.x,\n                               current_state.pose.position.y])\n\n        for i in range(start_idx, len(trajectory.poses)):\n            point = np.array([\n                trajectory.poses[i].pose.position.x,\n                trajectory.poses[i].pose.position.y\n            ])\n\n            distance = np.linalg.norm(point - current_pos)\n            if distance >= self.lookahead_distance:\n                return i\n\n        # If no point is far enough, return the last point\n        return len(trajectory.poses) - 1\n\n    def compute_control(self, current_state, trajectory, target_idx):\n        # Pure pursuit controller\n        target_point = trajectory.poses[target_idx]\n\n        # Transform target point to robot frame\n        robot_pos = np.array([current_state.pose.position.x,\n                             current_state.pose.position.y])\n        target_pos = np.array([target_point.pose.position.x,\n                              target_point.pose.position.y])\n\n        # Calculate heading error\n        target_vector = target_pos - robot_pos\n        robot_heading = current_state.pose.orientation  # Convert to angle\n\n        # Calculate control command based on heading error\n        # This would involve more complex calculations in practice\n        linear_vel = min(0.5, np.linalg.norm(target_vector))\n        angular_vel = self.calculate_angular_command(\n            target_vector, robot_heading\n        )\n\n        return linear_vel, angular_vel\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(e.h3,{id:"gpu-accelerated-planning",children:"GPU-Accelerated Planning"}),"\n",(0,a.jsx)(e.p,{children:"Leverage Isaac's GPU acceleration for motion planning:"}),"\n",(0,a.jsx)(e.h4,{id:"parallel-collision-detection",children:"Parallel Collision Detection"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# CUDA kernel for parallel collision detection (conceptual)\n"""\n__global__ void check_collisions_kernel(\n    float* configurations,\n    int num_configs,\n    float* obstacle_data,\n    int num_obstacles,\n    bool* collision_results\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= num_configs) return;\n\n    // Check collision for configuration at idx\n    collision_results[idx] = is_collision_free(\n        configurations + idx * CONFIG_DIM,\n        obstacle_data,\n        num_obstacles\n    );\n}\n"""\n'})}),"\n",(0,a.jsx)(e.h4,{id:"batch-processing",children:"Batch Processing"}),"\n",(0,a.jsx)(e.p,{children:"Process multiple planning requests simultaneously:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Temporal batching"}),": Combine multiple time steps"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Spatial batching"}),": Process multiple robot configurations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multi-query planning"}),": Share computation across multiple queries"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(e.p,{children:"Efficient memory usage for real-time planning:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory pools"}),": Pre-allocate frequently used structures"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"GPU memory optimization"}),": Minimize transfers between CPU and GPU"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Streaming"}),": Process data in chunks rather than all at once"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"integration-with-perception-systems",children:"Integration with Perception Systems"}),"\n",(0,a.jsx)(e.h3,{id:"perception-planning-coupling",children:"Perception-Planning Coupling"}),"\n",(0,a.jsx)(e.p,{children:"Motion planning relies on perception data:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class PerceptionAwarePlanner:\n    def __init__(self, motion_planner, perception_system):\n        self.motion_planner = motion_planner\n        self.perception = perception_system\n        self.uncertainty_model = self.initialize_uncertainty_model()\n\n    def plan_with_uncertainty(self, start, goal, confidence_threshold=0.8):\n        # Get perception data with uncertainty estimates\n        obstacles = self.perception.get_detected_obstacles()\n        uncertainty_map = self.perception.get_uncertainty_map()\n\n        # Plan considering perception uncertainty\n        safe_path = self.motion_planner.plan_with_uncertainty(\n            start, goal, obstacles, uncertainty_map, confidence_threshold\n        )\n\n        return safe_path\n\n    def update_environment_model(self, sensor_data):\n        # Update environment model based on new sensor data\n        new_obstacles = self.perception.process_sensor_data(sensor_data)\n\n        # Update motion planner with new information\n        self.motion_planner.update_environment(new_obstacles)\n\n        # Potentially replan if environment changed significantly\n        if self.environment_changed(new_obstacles):\n            self.request_replanning()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"quality-assurance-and-validation",children:"Quality Assurance and Validation"}),"\n",(0,a.jsx)(e.h3,{id:"planning-quality-metrics",children:"Planning Quality Metrics"}),"\n",(0,a.jsx)(e.p,{children:"Evaluate motion planning performance:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Completeness"}),": Does the planner find a solution when one exists?"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimality"}),": How close is the solution to optimal?"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Computational efficiency"}),": Planning time and memory usage"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Solution quality"}),": Path length, smoothness, safety margin"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"simulation-based-validation",children:"Simulation-Based Validation"}),"\n",(0,a.jsx)(e.p,{children:"Use Isaac Sim for planning validation:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Synthetic environments"}),": Test in diverse simulated scenarios"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stress testing"}),": Validate performance under extreme conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Regression testing"}),": Ensure updates don't degrade planning quality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Edge case validation"}),": Test rare but critical scenarios"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Motion planning and trajectory generation form the bridge between perception and action in robotic systems. The NVIDIA Isaac platform provides GPU-accelerated tools that enable real-time planning for complex robotic applications, from simple mobile robots to sophisticated manipulation systems."}),"\n",(0,a.jsx)(e.p,{children:"The combination of sampling-based planners, optimization techniques, and GPU acceleration allows robots to navigate complex, dynamic environments while satisfying kinematic and dynamic constraints. In the next chapter, we'll explore how these planning systems integrate with edge deployment strategies to create efficient, real-time robotic systems."})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);