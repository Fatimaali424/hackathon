"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1450],{550(n,e,o){o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3/lab-8-motion-control","title":"Lab 8: Motion Planning and Control Implementation","description":"Overview","source":"@site/docs/module-3/lab-8-motion-control.md","sourceDirName":"module-3","slug":"/module-3/lab-8-motion-control","permalink":"/hackathon/docs/module-3/lab-8-motion-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Fatimaali424/hackathon/edit/main/website/docs/module-3/lab-8-motion-control.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Lab 7: Basic Perception Pipeline with Isaac","permalink":"/hackathon/docs/module-3/lab-7-perception-pipeline"},"next":{"title":"Lab 9: Edge Deployment and Optimization","permalink":"/hackathon/docs/module-3/lab-9-edge-deployment"}}');var r=o(4848),i=o(8453);const s={sidebar_position:6},a="Lab 8: Motion Planning and Control Implementation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Hardware and Software Requirements",id:"hardware-and-software-requirements",level:2},{value:"Required Hardware",id:"required-hardware",level:3},{value:"Required Software",id:"required-software",level:3},{value:"Lab Setup",id:"lab-setup",level:2},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"Simulation Environment",id:"simulation-environment",level:3},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Basic Motion Planner",id:"step-1-basic-motion-planner",level:3},{value:"Step 2: Pure Pursuit Controller",id:"step-2-pure-pursuit-controller",level:3},{value:"Step 3: PID Controller for Velocity Control",id:"step-3-pid-controller-for-velocity-control",level:3},{value:"Step 4: Integrated Motion Control Node",id:"step-4-integrated-motion-control-node",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Simulation Testing",id:"simulation-testing",level:3},{value:"Performance Evaluation",id:"performance-evaluation",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Dynamic Obstacle Avoidance",id:"dynamic-obstacle-avoidance",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Lab Deliverables",id:"lab-deliverables",level:2},{value:"Assessment Criteria",id:"assessment-criteria",level:2},{value:"Extensions (Optional)",id:"extensions-optional",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"lab-8-motion-planning-and-control-implementation",children:"Lab 8: Motion Planning and Control Implementation"})}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"This lab focuses on implementing motion planning and control systems using NVIDIA Isaac's tools. You will learn to create path planners, implement control algorithms, and integrate them with perception systems to create a complete autonomous navigation solution."}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(e.p,{children:"After completing this lab, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Implement sampling-based motion planners (RRT, PRM)"}),"\n",(0,r.jsx)(e.li,{children:"Design and tune PID controllers for robot motion"}),"\n",(0,r.jsx)(e.li,{children:"Integrate motion planning with perception and control systems"}),"\n",(0,r.jsx)(e.li,{children:"Evaluate path quality and control performance"}),"\n",(0,r.jsx)(e.li,{children:"Implement obstacle avoidance and dynamic replanning"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Completion of Module 1 (ROS 2 fundamentals)"}),"\n",(0,r.jsx)(e.li,{children:"Completion of Module 2 (Simulation concepts)"}),"\n",(0,r.jsx)(e.li,{children:"Completion of Module 3 (Isaac perception)"}),"\n",(0,r.jsx)(e.li,{children:"Understanding of basic control theory"}),"\n",(0,r.jsx)(e.li,{children:"Basic knowledge of motion planning concepts"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"hardware-and-software-requirements",children:"Hardware and Software Requirements"}),"\n",(0,r.jsx)(e.h3,{id:"required-hardware",children:"Required Hardware"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mobile robot platform (TurtleBot3, Jackal, or similar)"}),"\n",(0,r.jsx)(e.li,{children:"Jetson platform for computation (if using physical robot)"}),"\n",(0,r.jsx)(e.li,{children:"RGB-D camera for perception"}),"\n",(0,r.jsx)(e.li,{children:"LIDAR for obstacle detection (if not integrated in camera)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"required-software",children:"Required Software"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"ROS 2 Humble Hawksbill"}),"\n",(0,r.jsx)(e.li,{children:"Isaac ROS Navigation packages"}),"\n",(0,r.jsx)(e.li,{children:"Navigation2 (Nav2) packages"}),"\n",(0,r.jsx)(e.li,{children:"Gazebo or Isaac Sim for simulation (recommended)"}),"\n",(0,r.jsx)(e.li,{children:"Python 3.10+ with NumPy, SciPy, Matplotlib"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"lab-setup",children:"Lab Setup"}),"\n",(0,r.jsx)(e.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Install Navigation packages:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"sudo apt update\nsudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\nsudo apt install ros-humble-isaac-ros-nav2 ros-humble-isaac-ros-navigation\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Create workspace:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/motion_control_ws/src\ncd ~/motion_control_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Verify installation:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"ros2 run nav2_util lifecycle_bringup\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"simulation-environment",children:"Simulation Environment"}),"\n",(0,r.jsx)(e.p,{children:"For this lab, we'll use a simulated environment. Create the following launch file:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# motion_control_sim_launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n\n    # Launch Gazebo simulation\n    gazebo_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ])\n    )\n\n    # Launch robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'use_sim_time': use_sim_time,\n            'robot_description': '<robot name=\"test\"><link name=\"base_link\"/></robot>'\n        }]\n    )\n\n    # Launch the motion control node\n    motion_control_node = Node(\n        package='motion_control_lab',\n        executable='motion_control_node',\n        name='motion_control_node',\n        parameters=[{\n            'use_sim_time': use_sim_time,\n            'robot_frame': 'base_link',\n            'map_frame': 'map',\n            'controller_frequency': 50.0\n        }]\n    )\n\n    return LaunchDescription([\n        DeclareLaunchArgument('use_sim_time', default_value='true'),\n        gazebo_launch,\n        robot_state_publisher,\n        motion_control_node\n    ])\n"})}),"\n",(0,r.jsx)(e.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,r.jsx)(e.h3,{id:"step-1-basic-motion-planner",children:"Step 1: Basic Motion Planner"}),"\n",(0,r.jsx)(e.p,{children:"Create a simple RRT-based motion planner:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# rrt_planner.py\n\nimport numpy as np\nimport random\nfrom scipy.spatial import KDTree\nimport math\n\nclass RRTPlanner:\n    def __init__(self, start, goal, bounds, obstacles=None):\n        self.start = np.array(start)\n        self.goal = np.array(goal)\n        self.bounds = bounds  # [(min_x, max_x), (min_y, max_y)]\n        self.obstacles = obstacles or []\n        self.max_iter = 10000\n        self.step_size = 0.5\n        self.goal_bias = 0.2\n\n        # RRT tree: {node_index: (configuration, parent_index)}\n        self.tree = {0: (self.start, None)}\n        self.nodes = [self.start]  # List of configurations\n        self.node_count = 1\n\n    def plan(self):\n        """Plan path from start to goal using RRT algorithm"""\n        for i in range(self.max_iter):\n            # Sample random point\n            if random.random() < self.goal_bias:\n                q_rand = self.goal\n            else:\n                q_rand = self.sample_free_space()\n\n            # Find nearest node in tree\n            nearest_idx = self.nearest_node(q_rand)\n\n            # Extend tree toward random point\n            q_new = self.extend_toward(nearest_idx, q_rand)\n\n            if q_new is not None:\n                # Add new node to tree\n                self.tree[self.node_count] = (q_new, nearest_idx)\n                self.nodes.append(q_new)\n\n                # Check if goal is reached\n                if self.distance(q_new, self.goal) < self.step_size:\n                    return self.reconstruct_path(self.node_count)\n\n                self.node_count += 1\n\n        return None  # No path found\n\n    def sample_free_space(self):\n        """Sample a random configuration in free space"""\n        while True:\n            # Sample random point in bounds\n            x = random.uniform(self.bounds[0][0], self.bounds[0][1])\n            y = random.uniform(self.bounds[1][0], self.bounds[1][1])\n            q_rand = np.array([x, y])\n\n            # Check if point is collision-free\n            if self.is_collision_free(q_rand):\n                return q_rand\n\n    def nearest_node(self, q_rand):\n        """Find nearest node in tree to q_rand using KDTree"""\n        if len(self.nodes) == 1:\n            return 0\n\n        # Use KDTree for efficient nearest neighbor search\n        tree = KDTree(self.nodes)\n        distance, idx = tree.query(q_rand)\n        return idx\n\n    def extend_toward(self, nearest_idx, q_rand):\n        """Extend tree from nearest node toward q_rand"""\n        q_nearest = self.tree[nearest_idx][0]\n\n        # Calculate direction vector\n        direction = q_rand - q_nearest\n        distance = np.linalg.norm(direction)\n\n        if distance < self.step_size:\n            q_new = q_rand\n        else:\n            # Normalize and scale direction\n            direction = direction / distance * self.step_size\n            q_new = q_nearest + direction\n\n        # Check if path from nearest to new is collision-free\n        if self.is_path_collision_free(q_nearest, q_new):\n            return q_new\n\n        return None\n\n    def is_collision_free(self, q):\n        """Check if configuration q is collision-free"""\n        for obs in self.obstacles:\n            if self.point_in_obstacle(q, obs):\n                return False\n        return True\n\n    def is_path_collision_free(self, q_from, q_to):\n        """Check if path from q_from to q_to is collision-free"""\n        # Simple linear interpolation check\n        steps = int(np.linalg.norm(q_to - q_from) / 0.1)  # Check every 0.1m\n        for i in range(1, steps + 1):\n            t = i / steps\n            q_check = q_from + t * (q_to - q_from)\n            if not self.is_collision_free(q_check):\n                return False\n        return True\n\n    def point_in_obstacle(self, point, obstacle):\n        """Check if point is inside obstacle (circle or rectangle)"""\n        if len(obstacle) == 3:  # Circle: [x, y, radius]\n            center = np.array(obstacle[:2])\n            radius = obstacle[2]\n            return np.linalg.norm(point - center) <= radius\n        elif len(obstacle) == 4:  # Rectangle: [x, y, width, height]\n            x, y, w, h = obstacle\n            px, py = point\n            return (x <= px <= x + w) and (y <= py <= y + h)\n        return False\n\n    def reconstruct_path(self, goal_node_idx):\n        """Reconstruct path from goal to start"""\n        path = []\n        current_idx = goal_node_idx\n\n        while current_idx is not None:\n            config = self.tree[current_idx][0]\n            path.append(config)\n            current_idx = self.tree[current_idx][1]\n\n        return path[::-1]  # Reverse to get start->goal path\n\n    def distance(self, q1, q2):\n        """Calculate Euclidean distance between configurations"""\n        return np.linalg.norm(q1 - q2)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"step-2-pure-pursuit-controller",children:"Step 2: Pure Pursuit Controller"}),"\n",(0,r.jsx)(e.p,{children:"Create a path-following controller:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# pure_pursuit_controller.py\n\nimport numpy as np\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Path\nimport math\n\nclass PurePursuitController:\n    def __init__(self, lookahead_distance=1.0, max_linear_vel=1.0, max_angular_vel=1.0):\n        self.lookahead_distance = lookahead_distance\n        self.max_linear_vel = max_linear_vel\n        self.max_angular_vel = max_angular_vel\n\n        self.path = None\n        self.current_pose = None\n        self.path_index = 0\n\n    def set_path(self, path):\n        """Set the path to follow"""\n        self.path = path\n        self.path_index = 0\n\n    def set_current_pose(self, pose):\n        """Set the current robot pose"""\n        self.current_pose = pose\n\n    def compute_control(self):\n        """Compute control command to follow path"""\n        if self.path is None or self.current_pose is None:\n            return Twist()\n\n        # Find lookahead point\n        lookahead_point = self.find_lookahead_point()\n        if lookahead_point is None:\n            return Twist()\n\n        # Calculate control command\n        cmd = Twist()\n\n        # Calculate distance to lookahead point\n        dx = lookahead_point[0] - self.current_pose.position.x\n        dy = lookahead_point[1] - self.current_pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        # Linear velocity (proportional to distance, capped at max)\n        cmd.linear.x = min(self.max_linear_vel, distance * 0.5)\n\n        # Calculate heading to lookahead point\n        target_angle = math.atan2(dy, dx)\n\n        # Get current robot orientation (assuming simple 2D orientation)\n        current_angle = self.get_current_yaw()\n\n        # Calculate angular error\n        angle_error = self.normalize_angle(target_angle - current_angle)\n\n        # Angular velocity (proportional to angle error)\n        cmd.angular.z = max(-self.max_angular_vel,\n                           min(self.max_angular_vel, angle_error * 2.0))\n\n        return cmd\n\n    def find_lookahead_point(self):\n        """Find point on path at lookahead distance"""\n        if self.path_index >= len(self.path.poses):\n            return None\n\n        # Start from current path index\n        for i in range(self.path_index, len(self.path.poses)):\n            pose = self.path.poses[i]\n            dx = pose.pose.position.x - self.current_pose.position.x\n            dy = pose.pose.position.y - self.current_pose.position.y\n            distance = math.sqrt(dx*dx + dy*dy)\n\n            if distance >= self.lookahead_distance:\n                # Update path index to improve efficiency\n                self.path_index = max(0, i - 5)  # Look back a bit to avoid skipping\n                return [pose.pose.position.x, pose.pose.position.y]\n\n        # If no point is far enough, return the last point\n        if self.path.poses:\n            last_pose = self.path.poses[-1]\n            return [last_pose.pose.position.x, last_pose.pose.position.y]\n\n        return None\n\n    def get_current_yaw(self):\n        """Extract yaw from current pose orientation"""\n        # Convert quaternion to yaw (simplified for 2D)\n        q = self.current_pose.orientation\n        siny_cosp = 2 * (q.w * q.z + q.x * q.y)\n        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def normalize_angle(self, angle):\n        """Normalize angle to [-pi, pi] range"""\n        while angle > math.pi:\n            angle -= 2 * math.pi\n        while angle < -math.pi:\n            angle += 2 * math.pi\n        return angle\n'})}),"\n",(0,r.jsx)(e.h3,{id:"step-3-pid-controller-for-velocity-control",children:"Step 3: PID Controller for Velocity Control"}),"\n",(0,r.jsx)(e.p,{children:"Implement a PID controller for more precise velocity control:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# pid_controller.py\n\nimport time\n\nclass PIDController:\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, output_limits=None):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.output_limits = output_limits  # (min, max)\n\n        self.reset()\n\n    def reset(self):\n        """Reset the PID controller"""\n        self.last_error = 0.0\n        self.integral = 0.0\n        self.last_time = time.time()\n\n    def compute(self, error):\n        """Compute PID output given error"""\n        current_time = time.time()\n        dt = current_time - self.last_time\n\n        if dt <= 0.0:\n            dt = 1e-6  # Prevent division by zero\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        derivative = (error - self.last_error) / dt\n        d_term = self.kd * derivative\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        # Apply output limits\n        if self.output_limits:\n            min_out, max_out = self.output_limits\n            output = max(min_out, min(max_out, output))\n\n        # Update for next iteration\n        self.last_error = error\n        self.last_time = current_time\n\n        return output\n\nclass VelocityController:\n    def __init__(self):\n        # PID controllers for linear and angular velocities\n        self.linear_pid = PIDController(\n            kp=1.0, ki=0.1, kd=0.05,\n            output_limits=(-1.0, 1.0)\n        )\n        self.angular_pid = PIDController(\n            kp=2.0, ki=0.1, kd=0.1,\n            output_limits=(-1.0, 1.0)\n        )\n\n    def compute_velocity_commands(self, linear_error, angular_error):\n        """Compute velocity commands from position/orientation errors"""\n        linear_vel = self.linear_pid.compute(linear_error)\n        angular_vel = self.angular_pid.compute(angular_error)\n\n        return linear_vel, angular_vel\n'})}),"\n",(0,r.jsx)(e.h3,{id:"step-4-integrated-motion-control-node",children:"Step 4: Integrated Motion Control Node"}),"\n",(0,r.jsx)(e.p,{children:"Create the main motion control node that integrates planning and control:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# motion_control_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\nfrom nav_msgs.msg import Path, Odometry\nfrom sensor_msgs.msg import LaserScan\nfrom visualization_msgs.msg import Marker\nfrom std_msgs.msg import Header\nimport numpy as np\nfrom rrt_planner import RRTPlanner\nfrom pure_pursuit_controller import PurePursuitController\nfrom pid_controller import VelocityController\n\nclass MotionControlNode(Node):\n    def __init__(self):\n        super().__init__('motion_control_node')\n\n        # Parameters\n        self.declare_parameter('robot_frame', 'base_link')\n        self.declare_parameter('map_frame', 'map')\n        self.declare_parameter('controller_frequency', 50.0)\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.path_pub = self.create_publisher(Path, '/motion_control/path', 10)\n        self.marker_pub = self.create_publisher(Marker, '/motion_control/waypoints', 10)\n\n        # Subscribers\n        self.odom_sub = self.create_subscription(\n            Odometry, '/odom', self.odom_callback, 10\n        )\n        self.goal_sub = self.create_subscription(\n            PoseStamped, '/move_base_simple/goal', self.goal_callback, 10\n        )\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10\n        )\n\n        # Initialize components\n        self.current_pose = None\n        self.current_goal = None\n        self.path = None\n        self.rrt_planner = None\n        self.controller = PurePursuitController(\n            lookahead_distance=1.0,\n            max_linear_vel=0.5,\n            max_angular_vel=1.0\n        )\n        self.velocity_controller = VelocityController()\n\n        # Timer for control loop\n        controller_freq = self.get_parameter('controller_frequency').value\n        self.control_timer = self.create_timer(1.0/controller_freq, self.control_loop)\n\n        # Obstacles from laser scan\n        self.obstacles = []\n\n        self.get_logger().info('Motion Control Node initialized')\n\n    def odom_callback(self, msg):\n        \"\"\"Update current robot pose\"\"\"\n        self.current_pose = msg.pose.pose\n\n    def goal_callback(self, msg):\n        \"\"\"Plan path to new goal\"\"\"\n        if self.current_pose is None:\n            self.get_logger().warn('Cannot plan without current pose')\n            return\n\n        # Extract goal position\n        goal_x = msg.pose.position.x\n        goal_y = msg.pose.position.y\n        start_x = self.current_pose.position.x\n        start_y = self.current_pose.position.y\n\n        # Define bounds for planning (expand from current position)\n        bounds = [\n            (min(start_x, goal_x) - 5, max(start_x, goal_x) + 5),\n            (min(start_y, goal_y) - 5, max(start_y, goal_y) + 5)\n        ]\n\n        # Create planner with obstacles\n        self.rrt_planner = RRTPlanner(\n            start=[start_x, start_y],\n            goal=[goal_x, goal_y],\n            bounds=bounds,\n            obstacles=self.obstacles\n        )\n\n        # Plan path\n        path = self.rrt_planner.plan()\n\n        if path is not None:\n            self.get_logger().info(f'Path found with {len(path)} waypoints')\n            self.publish_path(path)\n            self.path = path\n            self.controller.set_path(self.create_path_msg(path))\n        else:\n            self.get_logger().warn('No path found to goal')\n\n    def scan_callback(self, msg):\n        \"\"\"Process laser scan to detect obstacles\"\"\"\n        # Convert laser scan to obstacle points\n        angle_min = msg.angle_min\n        angle_increment = msg.angle_increment\n\n        self.obstacles = []\n        for i, range_val in enumerate(msg.ranges):\n            if not (np.isnan(range_val) or np.isinf(range_val)) and range_val < 2.0:\n                angle = angle_min + i * angle_increment\n                x = range_val * np.cos(angle)\n                y = range_val * np.sin(angle)\n                # Add as circular obstacle\n                self.obstacles.append([x, y, 0.3])  # 0.3m radius\n\n    def control_loop(self):\n        \"\"\"Main control loop\"\"\"\n        if self.current_pose is None or self.path is None:\n            return\n\n        # Update current pose in controller\n        self.controller.set_current_pose(self.current_pose)\n\n        # Compute control command\n        cmd = self.controller.compute_control()\n\n        # Publish command\n        self.cmd_vel_pub.publish(cmd)\n\n        # Check if goal is reached\n        if self.current_goal is not None:\n            goal_dist = self.distance_to_goal()\n            if goal_dist < 0.5:  # Within 0.5m of goal\n                self.get_logger().info('Goal reached!')\n                self.path = None\n                self.current_goal = None\n\n    def distance_to_goal(self):\n        \"\"\"Calculate distance to goal\"\"\"\n        if self.current_pose is None or self.current_goal is None:\n            return float('inf')\n\n        dx = self.current_goal.position.x - self.current_pose.position.x\n        dy = self.current_goal.position.y - self.current_pose.position.y\n        return np.sqrt(dx*dx + dy*dy)\n\n    def publish_path(self, path_points):\n        \"\"\"Publish path for visualization\"\"\"\n        path_msg = Path()\n        path_msg.header = Header()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = 'map'\n\n        for point in path_points:\n            pose = PoseStamped()\n            pose.header = path_msg.header\n            pose.pose.position.x = point[0]\n            pose.pose.position.y = point[1]\n            pose.pose.position.z = 0.0\n            path_msg.poses.append(pose)\n\n        self.path_pub.publish(path_msg)\n\n    def create_path_msg(self, path_points):\n        \"\"\"Create Path message from path points\"\"\"\n        path_msg = Path()\n        path_msg.header.frame_id = 'map'\n\n        for point in path_points:\n            pose = PoseStamped()\n            pose.pose.position.x = float(point[0])\n            pose.pose.position.y = float(point[1])\n            pose.pose.position.z = 0.0\n            path_msg.poses.append(pose)\n\n        return path_msg\n\ndef main(args=None):\n    rclpy.init(args=args)\n    motion_control_node = MotionControlNode()\n\n    try:\n        rclpy.spin(motion_control_node)\n    except KeyboardInterrupt:\n        motion_control_node.get_logger().info('Shutting down Motion Control Node')\n    finally:\n        motion_control_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,r.jsx)(e.h3,{id:"simulation-testing",children:"Simulation Testing"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Launch the simulation:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"ros2 launch motion_control_lab motion_control_sim_launch.py\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Send a navigation goal:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# In another terminal\nros2 run motion_control_lab send_goal.py\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Monitor the robot's path following:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"rqt_plot /motion_control/path\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"performance-evaluation",children:"Performance Evaluation"}),"\n",(0,r.jsx)(e.p,{children:"Create an evaluation script to measure controller performance:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# evaluate_controller.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nimport numpy as np\nimport time\n\nclass ControllerEvaluator(Node):\n    def __init__(self):\n        super().__init__('controller_evaluator')\n\n        self.path_sub = self.create_subscription(\n            Path, '/motion_control/path', self.path_callback, 10\n        )\n        self.pose_sub = self.create_subscription(\n            PoseStamped, '/robot/ground_truth_pose', self.pose_callback, 10\n        )\n\n        self.reference_path = None\n        self.tracking_errors = []\n        self.execution_times = []\n\n    def path_callback(self, msg):\n        \"\"\"Store reference path\"\"\"\n        self.reference_path = msg.poses\n\n    def pose_callback(self, msg):\n        \"\"\"Evaluate tracking performance\"\"\"\n        if self.reference_path is not None:\n            # Calculate distance to reference path\n            current_pos = np.array([msg.pose.position.x, msg.pose.position.y])\n\n            min_distance = float('inf')\n            for pose in self.reference_path:\n                path_pos = np.array([\n                    pose.pose.position.x,\n                    pose.pose.position.y\n                ])\n                dist = np.linalg.norm(current_pos - path_pos)\n                min_distance = min(min_distance, dist)\n\n            self.tracking_errors.append(min_distance)\n\n            # Calculate statistics periodically\n            if len(self.tracking_errors) % 50 == 0:\n                avg_error = np.mean(self.tracking_errors[-50:])\n                max_error = np.max(self.tracking_errors[-50:])\n                self.get_logger().info(\n                    f'Path tracking - Avg error: {avg_error:.3f}m, '\n                    f'Max error: {max_error:.3f}m'\n                )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    evaluator = ControllerEvaluator()\n\n    try:\n        rclpy.spin(evaluator)\n    except KeyboardInterrupt:\n        # Print final statistics\n        if evaluator.tracking_errors:\n            avg_error = np.mean(evaluator.tracking_errors)\n            max_error = np.max(evaluator.tracking_errors)\n            std_error = np.std(evaluator.tracking_errors)\n\n            print(f'\\nController Performance:')\n            print(f'  Average tracking error: {avg_error:.3f}m')\n            print(f'  Maximum tracking error: {max_error:.3f}m')\n            print(f'  Standard deviation: {std_error:.3f}m')\n            print(f'  Total samples: {len(evaluator.tracking_errors)}')\n\n    evaluator.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,r.jsx)(e.h3,{id:"dynamic-obstacle-avoidance",children:"Dynamic Obstacle Avoidance"}),"\n",(0,r.jsx)(e.p,{children:"Implement dynamic obstacle avoidance by integrating with the costmap:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# dynamic_avoidance.py\n\nimport numpy as np\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\nclass DynamicAvoidance:\n    def __init__(self, safety_distance=0.5, avoidance_gain=2.0):\n        self.safety_distance = safety_distance\n        self.avoidance_gain = avoidance_gain\n\n    def compute_avoidance_command(self, cmd_vel, scan_data):\n        \"\"\"Modify velocity command to avoid obstacles\"\"\"\n        # Analyze laser scan for obstacles in front\n        front_scan = scan_data.ranges[len(scan_data.ranges)//2-30:len(scan_data.ranges)//2+30]\n        min_front_dist = min([r for r in front_scan if not np.isinf(r) and not np.isnan(r)], default=float('inf'))\n\n        # If obstacle is too close, reduce forward velocity\n        if min_front_dist < self.safety_distance:\n            reduction_factor = min_front_dist / self.safety_distance\n            cmd_vel.linear.x *= reduction_factor\n            cmd_vel.linear.x = max(0.0, cmd_vel.linear.x)  # Don't go backward\n\n        # Add lateral avoidance if needed\n        left_scan = scan_data.ranges[:len(scan_data.ranges)//4]\n        right_scan = scan_data.ranges[3*len(scan_data.ranges)//4:]\n\n        min_left = min([r for r in left_scan if not np.isinf(r) and not np.isnan(r)], default=float('inf'))\n        min_right = min([r for r in right_scan if not np.isinf(r) and not np.isnan(r)], default=float('inf'))\n\n        # Turn away from closer obstacle\n        if min_left < self.safety_distance or min_right < self.safety_distance:\n            if min_left < min_right:\n                cmd_vel.angular.z = -0.5  # Turn right\n            else:\n                cmd_vel.angular.z = 0.5   # Turn left\n\n        return cmd_vel\n"})}),"\n",(0,r.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Robot oscillates around path:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Increase lookahead distance"}),"\n",(0,r.jsx)(e.li,{children:"Reduce linear velocity"}),"\n",(0,r.jsx)(e.li,{children:"Tune PID parameters"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Path planning fails:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Check obstacle representation"}),"\n",(0,r.jsx)(e.li,{children:"Verify bounds are appropriate"}),"\n",(0,r.jsx)(e.li,{children:"Increase max iterations"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Controller is too slow:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Increase controller frequency"}),"\n",(0,r.jsx)(e.li,{children:"Optimize path planning algorithm"}),"\n",(0,r.jsx)(e.li,{children:"Reduce path smoothing"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Robot collides with obstacles:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Increase safety margins"}),"\n",(0,r.jsx)(e.li,{children:"Improve obstacle detection"}),"\n",(0,r.jsx)(e.li,{children:"Add dynamic avoidance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"lab-deliverables",children:"Lab Deliverables"}),"\n",(0,r.jsx)(e.p,{children:"Complete the following tasks to finish the lab:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Implement the RRT planner"})," with basic obstacle avoidance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Create the pure pursuit controller"})," for path following"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Integrate planning and control"})," in a single node"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Evaluate performance"})," using the provided evaluation script"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Document your results"})," including:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Path planning success rate"}),"\n",(0,r.jsx)(e.li,{children:"Tracking accuracy statistics"}),"\n",(0,r.jsx)(e.li,{children:"Any challenges encountered and solutions"}),"\n",(0,r.jsx)(e.li,{children:"Suggestions for improvement"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"assessment-criteria",children:"Assessment Criteria"}),"\n",(0,r.jsx)(e.p,{children:"Your lab implementation will be assessed based on:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Functionality"}),": Does the motion control system work correctly?"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance"}),": Are tracking errors and planning times acceptable?"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Code Quality"}),": Is the code well-structured and documented?"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Problem Solving"}),": How effectively did you troubleshoot issues?"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Analysis"}),": Quality of performance evaluation and insights provided"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"extensions-optional",children:"Extensions (Optional)"}),"\n",(0,r.jsx)(e.p,{children:"For advanced students, consider implementing:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"D"})," or D"]})," Lite** for dynamic replanning"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MPC (Model Predictive Control)"})," for advanced control"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Multi-robot coordination"})," algorithms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Learning-based motion planning"})," approaches"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"This lab provided hands-on experience with motion planning and control systems using Isaac's tools. You learned to implement path planning algorithms, create controllers for path following, and integrate these components into a complete navigation system. These skills are essential for autonomous robotic applications."})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453(n,e,o){o.d(e,{R:()=>s,x:()=>a});var t=o(6540);const r={},i=t.createContext(r);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);